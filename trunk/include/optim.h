#ifndef __OPTIM_H__
#define __OPTIM_H__

/**
  \file
  Методы локальной оптимизации.
  
*/

/**
  \example xmin.c
*/

/**
  \example xneldermead.c
*/

/**
  Минимизация функции одного переменного.

  Используется комбинированный метод золотого сечения
  и квадратичной интерполяции.

  - Вход:
	- \f$fun\f$ - указатель на функцию
	- \f$a\f$ - левый конец исходного интервала
	- \f$b\f$ - правый конец исходного интервала
	- \f$abstol\f$ - желаемая длина интервала неопределенности конечного результата

  - Выход:
	- Функция возвращает найденное решение.

  Если \f$f\f$ имеет непрерывную вторую производную, положительную в точке
  минимума (не совпадающей ни с \f$a\f$, ни с \f$b\f$), то сходимость
  сверхлинейная порядка приблизительно \f$1.324\dots\f$
  В любом случае сходимость не может быть хуже, чем для метода золотого сечения.

  Функция является переводом фортрановской программы fmin из книги [FMM].
*/

double optim_min(double (*fun)(double), double a, double b, double abstol); 

/**
  Симплекс-метод Нелдера-Мида.

  Функция находит локальный минимум функции \f$f(x)\f$, зависящей от \f$n\f$
  переменных, \f$n\ge 2\f$. Для минимизации используется симплекс-метод Нелдера-Мида.
  Итерации метода продолжаются до тех пор, пока значения функции в вершинах
  текущего симплекса не будут отличаться более, чем на \f$tolf\f$, 
  и диаметр симплекса (в чебышевой норме) не будет превышать \f$tolx\f$.
  Алгоритм также останавливается при превышении максимально допустимого
  числа \f$maxfun\f$ вычислений значений функции или максимально допустимого 
  числа \f$maxiter\f$ итераций (построенных симплексов).

  - Вход:
    - \f$n\f$ - число переменных функции \f$f(x)\f$
    - \f$fun\f$ - указатель на функцию, вычисляющую \f$f(x)\f$
    - \f$x0\f$ - массив длины \f$n\f$, при \f$initsimplex = 0\f$ содержащий 
        координаты начального приближения 
    - \f$initsimplex\f$ - флаг, показывающий, передается ли функции одно начальное приближение
        \f$x0\f$ (при \f$initsimplex = 0\f$) или целый симплекс \f$x\f$
        (при \f$initsimplex = 1\f$)     
    - \f$x\f$ - \f$(n+1)\times n\f$-массив, при \f$initsimplex = 0\f$ содержащий 
        координаты вершин исходного симплекса 
    - \f$f\f$ - массив длины \f$n+1\f$
    - \f$tolf\f$ - допуск по значению функции
    - \f$tolx\f$ - допуск по \f$x\f$
    - \f$maxfunevals\f$ - максимальное число вычислений значений функции
    - \f$maxiter\f$ - максимальное число итераций
  - Выход:
    - \f$x0\f$ - найденная точка локального минимума
    - \f$f0\f$ - значение функции в этой точке
    - \f$x\f$ - координаты вершин последнего найденного симплекса
    - \f$f\f$ - значения функции \f$f(x)\f$ в вершинах последнего симплекса
    - \f$rc\f$ - код возврата:
      - \f$rc = 0\f$: значения функции в вершинах
        текущего симплекса отличаются не более, чем на \f$tolf\f$, 
        и диаметр симплекса (в чебышевой норме) не превышает \f$tolx\f$.
      - \f$rc = 1\f$: количество вычислений значений функции превысило \f$maxfun\f$
        или число итераций достигло \f$maxiter\f$
    - \f$nfunevals\f$ - колчество вычислений значений функции
    - \f$niter\f$ - число выполненных итераций
  - Рабочий массив:
    - \f$work\f$ - массив длины \f$4n\f$
*/
extern 
void optim_nelder_mead(
  double (*fun)(double*),
  size_t n,  
  double *x0,
  double *f0,
  int initsimplex,
  double *x,
  double *f,
  double tolf, double tolx,
  int maxfunevals, int maxiter,
  int *rc,
  int *nfunevals, int *niter,
  double *work);


#endif
